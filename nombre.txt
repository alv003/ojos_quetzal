    def estabilizador_imagen(self, imagen_base, imagen_a_estabilizar, radio=0.75, error_reproyeccion=4.0,
                             coincidencias=False):
        """This class returns a sequence of images taken from the camera stabilized with respect to the first image"""

        # Get keypoints and features
        (kpsBase, featuresBase) = self.obtener_puntos_interes(imagen_base)
        (kpsAdicional, featuresAdicional) = self.obtener_puntos_interes(imagen_a_estabilizar)

        # Find matches
        M = self.encontrar_coincidencias(imagen_base, imagen_a_estabilizar, kpsBase, kpsAdicional, featuresBase,
                                         featuresAdicional, radio)

        if M is None:
            print("Not enough matches")
            return None

        if len(M) > 4:
            # Construct the two sets of points
            ptsA = np.float32([kpsBase[i].pt for (_, i) in M])
            ptsB = np.float32([kpsAdicional[i].pt for (i, _) in M])

            # Compute the homography between the two sets of points
            (H, status) = cv2.findHomography(ptsA, ptsB, cv2.RANSAC, reprojThresh)

            # Apply homography to stabilize the second image
            estabilizada = cv2.warpPerspective(imagen_a_estabilizar, H, (imagen_base.shape[1], imagen_base.shape[0]))
            return estabilizada

        print("No matches found")
        return None

    def img_alignment_sequoia(self, img_base, img_a_estabilizar, width, height):
        """This class takes two images and makes a photogrammetric alignment.
           Returns two aligned images"""

        # Resize images to the same size
        base_resized = cv2.resize(img_base, (width, height), interpolation=cv2.INTER_LINEAR)
        additional_resized = cv2.resize(img_a_estabilizar, (width, height), interpolation=cv2.INTER_LINEAR)

        # Stabilize the second image with respect to the first image
        stabilized_image = self.estabilizador_imagen(base_resized, additional_resized)

        return base_resized, stabilized_image
